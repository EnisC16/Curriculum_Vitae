"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autoAlign = autoAlign;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _reactRelativePortal = _interopRequireDefault(require("react-relative-portal"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function delay(ms) {
  return new Promise(function (resolve) {
    setTimeout(resolve, ms);
  });
}

function getViewportRect() {
  var _ref = window || {},
      _ref$innerHeight = _ref.innerHeight,
      height = _ref$innerHeight === void 0 ? Infinity : _ref$innerHeight,
      _ref$innerWidth = _ref.innerWidth,
      width = _ref$innerWidth === void 0 ? Infinity : _ref$innerWidth;

  return {
    top: 0,
    left: 0,
    width: width,
    height: height
  };
}

function calcAlignmentRect(target, rect, alignment) {
  var _alignment = (0, _slicedToArray2["default"])(alignment, 2),
      firstAlign = _alignment[0],
      secondAlign = _alignment[1];

  return _objectSpread(_objectSpread({}, rect), {}, {
    top: firstAlign === 'top-absolute' || secondAlign === 'top-absolute' ? 0 : firstAlign === 'bottom-absolute' || secondAlign === 'bottom-absolute' ? getViewportRect().height - rect.height : firstAlign === 'top' ? target.top + target.height : firstAlign === 'bottom' ? target.top - rect.height : secondAlign === 'top' ? target.top : secondAlign === 'bottom' ? target.top + target.height - rect.height : // valign middle
    target.top + (target.height - rect.height) * 0.5,
    left: firstAlign === 'left-absolute' || secondAlign === 'left-absolute' ? 0 : firstAlign === 'right-absolute' || secondAlign === 'right-absolute' ? getViewportRect().width - rect.width : firstAlign === 'left' ? target.left + target.width : firstAlign === 'right' ? target.left - rect.width : secondAlign === 'left' ? target.left : secondAlign === 'right' ? target.left + target.width - rect.width : // halign center
    target.left + (target.width - rect.width) * 0.5
  });
}

function hasViewportIntersection(_ref2) {
  var top = _ref2.top,
      left = _ref2.left,
      width = _ref2.width,
      height = _ref2.height;

  var _getViewportRect = getViewportRect(),
      viewportWidth = _getViewportRect.width,
      viewportHeight = _getViewportRect.height;

  return top < 0 || top + height > viewportHeight || left < 0 || left + width > viewportWidth;
}

function isEqualRect(aRect, bRect) {
  if (aRect === bRect) {
    return true;
  }

  if (!aRect || !bRect) {
    return false;
  }

  return aRect.top === bRect.top && aRect.left === bRect.left && aRect.width === bRect.width && aRect.height === bRect.height;
}

function getCenterPoint(rect) {
  return {
    x: rect.left + 0.5 * rect.width,
    y: rect.top + 0.5 * rect.height
  };
}

function getPreferAlignment(rect) {
  if (!rect) {
    return {
      v: 'top',
      h: 'left'
    };
  }

  var _getCenterPoint = getCenterPoint(rect),
      rx = _getCenterPoint.x,
      ry = _getCenterPoint.y;

  var _getCenterPoint2 = getCenterPoint(getViewportRect()),
      vx = _getCenterPoint2.x,
      vy = _getCenterPoint2.y;

  return {
    h: rx < vx ? 'left' : 'right',
    v: ry < vy ? 'top' : 'bottom'
  };
}

function throttle(func, ms) {
  var last = 0;
  return function () {
    var now = Date.now();

    if (last + ms < now) {
      func.apply(void 0, arguments);
      last = now;
    }
  };
}

function ignoreFirstCall(func) {
  var called = false;
  return function () {
    if (called) {
      func.apply(void 0, arguments);
    }

    called = true;
  };
}

function removeAbsoluteAlign(alignment) {
  return alignment.map(function (a) {
    return a.replace(/-absolute$/, '');
  });
}

function getPossibleAlignments(alignmentStyle, align, target) {
  var _getPreferAlignment = getPreferAlignment(target),
      h = _getPreferAlignment.h,
      v = _getPreferAlignment.v;

  var alignments = [['top', 'left'], ['top', 'right'], ['top'], ['bottom', 'left'], ['bottom', 'right'], ['bottom'], ['left', 'top'], ['left', 'bottom'], ['left'], ['right', 'top'], ['right', 'bottom'], ['right'], ['top', "".concat(h, "-absolute")], ['bottom', "".concat(h, "-absolute")], ['left', "".concat(v, "-absolute")], ['right', "".concat(v, "-absolute")], ["".concat(v, "-absolute"), 'left'], ["".concat(v, "-absolute"), 'right'], ["".concat(h, "-absolute"), 'top'], ["".concat(h, "-absolute"), 'bottom'], ["".concat(v, "-absolute")], ["".concat(h, "-absolute")], ["".concat(v, "-absolute"), "".concat(h, "-absolute")]];
  return alignments.filter(function (_ref3) {
    var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2),
        firstAlign = _ref4[0],
        secondAlign = _ref4[1];

    return !align || firstAlign === align || secondAlign === align;
  }).filter(function (_ref5) {
    var _ref6 = (0, _slicedToArray2["default"])(_ref5, 2),
        firstAlign = _ref6[0],
        secondAlign = _ref6[1];

    return alignmentStyle === 'menu' ? secondAlign && /^(top|bottom)/.test(firstAlign) : true;
  });
}

var EMPTY_RECT = {
  top: 0,
  left: 0,
  width: 0,
  height: 0
};
/**
 *
 */

function autoAlign(options) {
  var triggerSelector = options.triggerSelector,
      alignmentStyle = options.alignmentStyle;
  return function (Cmp) {
    var _class, _temp;

    return _temp = _class = /*#__PURE__*/function (_React$Component) {
      (0, _inherits2["default"])(_class, _React$Component);

      var _super = _createSuper(_class);

      /* eslint-disable react/sort-comp */

      /* eslint-enable react/sort-comp */
      function _class(props) {
        var _this;

        (0, _classCallCheck2["default"])(this, _class);
        _this = _super.call(this, props);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "pid", null);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "node", null);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "content", void 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "context", void 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "requestRecalcAlignment", throttle( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
          var pid, _i, _arr, ms;

          return _regenerator["default"].wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  pid = (_this.pid || 0) + 1;
                  _this.pid = pid;
                  _i = 0, _arr = [0, 300, 400, 300, 200];

                case 3:
                  if (!(_i < _arr.length)) {
                    _context.next = 13;
                    break;
                  }

                  ms = _arr[_i];
                  _context.next = 7;
                  return delay(ms);

                case 7:
                  if (!(_this.pid !== pid)) {
                    _context.next = 9;
                    break;
                  }

                  return _context.abrupt("return");

                case 9:
                  _this.recalcAlignment();

                case 10:
                  _i++;
                  _context.next = 3;
                  break;

                case 13:
                  _this.pid = 0;

                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        })), 100));
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "recalcAlignment", function () {
          if (_this.node) {
            var triggerEl = _this.node;
            var matches = triggerEl.matches || triggerEl.matchesSelector || triggerEl.msMatchesSelector;

            try {
              while (triggerEl) {
                if (matches.call(triggerEl, triggerSelector)) {
                  break;
                }

                triggerEl = triggerEl.parentElement;
              }
            } catch (e) {
              triggerEl = null;
            } // eslint-disable-next-line react/destructuring-assignment


            var oldTriggerNodeRect = _this.state.triggerNodeRect;

            if (triggerEl) {
              var _triggerEl$getBoundin = triggerEl.getBoundingClientRect(),
                  top = _triggerEl$getBoundin.top,
                  left = _triggerEl$getBoundin.left,
                  width = _triggerEl$getBoundin.width,
                  height = _triggerEl$getBoundin.height;

              if (!isEqualRect(oldTriggerNodeRect, {
                top: top,
                left: left,
                width: width,
                height: height
              })) {
                _this.updateAlignment({
                  top: top,
                  left: left,
                  width: width,
                  height: height
                });
              } else {
                _this.updateAlignment(oldTriggerNodeRect);
              }
            } else {
              _this.updateAlignment(oldTriggerNodeRect);
            }
          }
        });
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "updateAlignment", function () {
          var triggerNodeRect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_RECT;
          var _this$state = _this.state,
              oldTriggerNodeRect = _this$state.triggerNodeRect,
              oldAlignment = _this$state.alignment;
          var rootNodeRect = _this.node ? _this.node.getBoundingClientRect() : EMPTY_RECT;

          var _ref8 = _this.content && _this.content.node ? _this.content.node.getBoundingClientRect() : EMPTY_RECT,
              contentRectWidth = _ref8.width,
              contentRectHeight = _ref8.height;

          var alignment = null;
          var possibleAlignments = getPossibleAlignments(alignmentStyle, _this.props.align, triggerNodeRect);

          var _iterator = _createForOfIteratorHelper(possibleAlignments),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var align = _step.value;
              var aRect = calcAlignmentRect(triggerNodeRect, {
                width: contentRectWidth,
                height: contentRectHeight
              }, align);

              if (!hasViewportIntersection(aRect)) {
                alignment = align;
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          if (!alignment) {
            alignment = possibleAlignments[possibleAlignments.length - 1];
          }

          if (alignment[0] !== oldAlignment[0] || alignment[1] !== oldAlignment[1]) {
            _this.setState({
              alignment: alignment,
              triggerNodeRect: triggerNodeRect,
              rootNodeRect: rootNodeRect
            });
          } else if (!oldTriggerNodeRect || triggerNodeRect.width !== oldTriggerNodeRect.width || triggerNodeRect.height !== oldTriggerNodeRect.height || /absolute$/.test(oldAlignment[0]) || /absolute$/.test(oldAlignment[1] || '')) {
            _this.setState({
              triggerNodeRect: triggerNodeRect,
              rootNodeRect: rootNodeRect
            });
          }
        });
        _this.state = {
          alignment: getPossibleAlignments(alignmentStyle, props.align)[0]
        };
        return _this;
      }

      (0, _createClass2["default"])(_class, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.requestRecalcAlignment();
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.pid = null;
          this.node = null;
          this.content = null;
        } // eslint-disable-next-line react/sort-comp

      }, {
        key: "render",
        value: function render() {
          var _this2 = this;

          var _this$state2 = this.state,
              _this$state2$triggerN = _this$state2.triggerNodeRect,
              triggerNodeRect = _this$state2$triggerN === void 0 ? EMPTY_RECT : _this$state2$triggerN,
              _this$state2$rootNode = _this$state2.rootNodeRect,
              rootNodeRect = _this$state2$rootNode === void 0 ? EMPTY_RECT : _this$state2$rootNode;
          var _this$props = this.props,
              _this$props$alignment = _this$props.alignment,
              alignment = _this$props$alignment === void 0 ? this.state.alignment : _this$props$alignment,
              additionalPortalClassName = _this$props.portalClassName,
              _this$props$portalSty = _this$props.portalStyle,
              additionalPortalStyle = _this$props$portalSty === void 0 ? {} : _this$props$portalSty,
              preventPortalize = _this$props.preventPortalize,
              children = _this$props.children,
              pprops = (0, _objectWithoutProperties2["default"])(_this$props, ["alignment", "portalClassName", "portalStyle", "preventPortalize", "children"]);
          var _this$context = this.context,
              _this$context$portalC = _this$context.portalClassName,
              portalClassName = _this$context$portalC === void 0 ? 'slds-scope' : _this$context$portalC,
              _this$context$portalS = _this$context.portalStyle,
              portalStyle = _this$context$portalS === void 0 ? {
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0
          } : _this$context$portalS; // eslint-disable-next-line prefer-const

          var _calcAlignmentRect = calcAlignmentRect(triggerNodeRect, rootNodeRect, alignment),
              top = _calcAlignmentRect.top,
              left = _calcAlignmentRect.left;

          if ((alignment[0] === 'top' || alignment[0] === 'bottom') && !alignment[1]) {
            left = triggerNodeRect.left + triggerNodeRect.width * 0.5;
          }

          var offsetTop = top - rootNodeRect.top;
          var offsetLeft = left - rootNodeRect.left;

          var content = /*#__PURE__*/_react["default"].createElement(Cmp, (0, _extends2["default"])({
            alignment: removeAbsoluteAlign(alignment),
            ref: function ref(cmp) {
              return _this2.content = cmp;
            }
          }, pprops), children);

          return preventPortalize || process.env.NODE_ENV === 'test' ? content : /*#__PURE__*/_react["default"].createElement("div", {
            ref: function ref(node) {
              return _this2.node = node;
            }
          }, /*#__PURE__*/_react["default"].createElement(_reactRelativePortal["default"], {
            fullWidth: true,
            left: offsetLeft,
            right: -offsetLeft,
            top: offsetTop,
            onScroll: ignoreFirstCall(this.requestRecalcAlignment),
            component: "div",
            className: (0, _classnames["default"])(portalClassName, additionalPortalClassName),
            style: _objectSpread(_objectSpread({}, portalStyle), additionalPortalStyle)
          }, this.state.triggerNodeRect ? content : /*#__PURE__*/_react["default"].createElement("div", {
            className: "slds-hidden"
          }, content)));
        }
      }]);
      return _class;
    }(_react["default"].Component), (0, _defineProperty2["default"])(_class, "contextTypes", {
      portalClassName: _propTypes["default"].string,
      portalStyle: _propTypes["default"].object // eslint-disable-line react/forbid-prop-types

    }), _temp;
  };
}
//# sourceMappingURL=AutoAlign.js.map